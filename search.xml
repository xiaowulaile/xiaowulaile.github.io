<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[面向对象那点事儿-继承]]></title>
      <url>%2F2013%2F10%2F05%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF-%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承的概念 JS继承：将别人的东西拿来自己用 1234567891011function Student()&#123;&#125;Student.prototype.say=function()&#123;&#125;;var s1=new Student();s1.say();//继承关系：s1继承自原型对象——&gt;s1.__proto__===原型对象//就像a继承自b——&gt;a.__proto__===b 继承的六种方式扩展原型继承方式 一个构造函数的prototype属性指向默认的原型对象，往默认的原型对象中添加属性、方法就可以为构造函数的实例提供共享的属性和方法 123456function foo1() &#123;&#125;;foo1.prototype.getName = function () &#123; console.log("HELLO 1");&#125;;var kk1 = new foo1();console.log(kk1.getName()); 替换原型对象继承方式 需要往构造函数的原型对象中添加多个属性、方法，如果使用扩展原型对象实现继承，代码冗余（重复） 将构造函数的prototype属性指向一个全新的对象，在这个对象中添加属性、方法(要注意添加constructor属性，指向构造函数本身) 123456789101112function foo2() &#123;&#125;;foo2.prototype = &#123; constructor:foo2, setName:function () &#123;&#125;, getName:function () &#123; console.log("HELLO 2"); &#125;&#125;;var kk2 = new foo2();console.log(kk2.getName()); 混入继承方式 已知2个对象（o1,o2），需要将o1的功能拷贝到o2中。 实现方式：for…in遍历o1对象的属性，将其属性值赋值到o2中 12345678910111213141516171819// 封装方法function mixin(target,source) &#123;for(var key in source)&#123;target[key] = source[key];&#125;return target;&#125;var o1 = &#123;getName:function () &#123;console.log("HELLO 3")&#125;&#125;;var o2 = &#123;&#125;;for(var key in o1)&#123; o2[key] = o1[key];&#125;console.log(o2.getName());var kk3 = mixin(o2,o1);console.log(kk3.getName()); 原型+混入继承方式 利用混入继承的原理，向原型对象中添加属性、和方法——&gt;mixin(Person.prototype,{a:10,b:function(){}) 1234// 调用的封装函数同上mixin函数var o4 = &#123;getName:function () &#123; console.log(&quot;HELLO 4&quot;)&#125;&#125;;var kk4 = mixin(foo1.prototype,o4);console.log(kk4.getName()); 经典继承方式 已知一个对象o，需要创建一个新的对象(o2)，这个新的对象继承自对象o 由于proto不是一个标准属性，不能出现在正式代码中，而且该属性也无法被修改 经典继承的使用场景：要创建一个对象（不需要关心构造函数）新对象需要继承自另一个指定的对象 1234567var oo1 = &#123;getName:function () &#123;console.log(&quot;HELLO 5&quot;)&#125;&#125;;//必要代码function foo5() &#123;&#125;;foo5.prototype = oo1;var kk5 = new foo5();console.log(kk5.getName()); 因为上面的必要代码是一定要有的，所以可以考虑将上面写法进行封装 12345678function create(o)&#123;function foo5()&#123;&#125;foo5.prototype=o;return new foo5();//返回的就是foo5的实例&#125;var kk5 = create(o);//kk5.__proto__===o ES5（IE9以下版本不支持）：Object.create()的实现原理就是源自于经典继承 12//也可这样调用var kk5 = Object.create(o);//kk5也是继承自对象o的 在旧的浏览器中应用经典继承： 1、首先应该先检测浏览器是否支持Object.create(),所以一般要进行兼容处理 12345678if(typeof Object.create !==&quot;function&quot;)&#123; Object.create=function(o)&#123; function F()&#123;&#125;//一个任意的构造函数 F.prototype=o;//设置构造函数的原型对象 return new F();//返回的就是F的实例 &#125;;&#125; 借用构造函数继承方式 利用构造函数继承（结合call/apply）涉及两个构造函数，一个父类构造函数，一个子类构造函数 父类构造函数的所有功能都能被子类构造函数适用 注意：由于要借用父类构造函数，所以父类构造函数的功能要对子类对象通用 123456789101112function foo6(getName) &#123; this.getName = getName;&#125;;function foo66(getName,ownName) &#123; foo6.call(this,getName); this.ownName = ownName;&#125;var kk6 = new foo66(&quot;HELLO 6&quot;,&quot;tomas&quot;);console.log(kk6.getName); //HELLO 6console.log(kk6.ownName); //tomas 由于父构造函数对子构造函数来说，它的属性与方法都是可用的，那么问题出现了：当我自身也拥有和父构造函数一样的属性时，就会出现污染问题，而且这种场景常见，所以借用构造函数实现继承的方式不是首选。 12345678910111213141516function f1(name,age,gender)&#123; this.name=name; this.age=age; this.gender=&quot;男&quot;;&#125;function f2(name,age,length)&#123; this.name=name; this.age=age; this.length=length;&#125;function f2(name,age,length)&#123; f1.call(this,name,age); this.length=length;&#125;var ff2=new f2(&quot;Janda&quot;,16,165);//此处ff2实例拥有name age, gender length这4个属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象那点事儿-原型链]]></title>
      <url>%2F2013%2F10%2F04%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF-%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
      <content type="text"><![CDATA[原型链的概念 JS由对象组成，一个对象就有它的原型对象(proto)，原型对象也有它的原型对象，一直到原型链的顶端，这样构成了一个具有链条形状的结构，称之为原型链 12345678//1、对象字面量的原型链var o1=&#123; age:10 &#125;; //new Object()//2、通过构造函数创建的对象原型链function Person(name)&#123; this.name=name;&#125;var p1=new Person(&quot;威震天&quot;); 原型链图内置对象原型图 结合构造函数、原型对象、实例三者之间的关系 原型对象是构造函数的prototype属性 构造函数的实例的proto属性指向原型对象 原型对象有一个constructor属性指向构造函数本身 内置对象以数组为例，已知数组arr = [1,3,5];,则可以得出arr.__proto__===Array.prototype,arr.__proto__.__proto__===Object.prototype 内置对象与对象原型图 函数原型图函数的创建 任何函数都是通过Function创建出来的（任何函数都是Function的实例）1function f()&#123;&#125;//new Function() 创建一个无参无返回值的函数 1var f1=new Function(&quot;var a=1;var b=2;console.log(a+b);&quot;); 创建一个有一个参数，无返回值的函数 12var f2=new Function(&quot;num&quot;,&quot;console.log(num);&quot;);f2(10); 创建一个具有3个参数，有返回值的函数 12var f3=new Function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;return a+b+c; &quot;);console.log(f3(1,3,5)); 创建一个经典继承的函数 1234var f5=new Function(&quot;o&quot;,&quot;function F()&#123;&#125; &quot; +&quot;F.prototype=o;&quot; +&quot;return new F();&quot;);console.log(f5(&#123;age:10&#125;)); 一些总结： 1、几乎所有函数都有prototype属性（Function.prototype这个函数上没有） 2、所有对象中都有__proto__属性（Object.prototype该属性的值null） ——&gt;几乎所有函数都有prototype__proto__属性 3、函数都是Function的实例（函数是通过Function创建出来的对象） ——&gt;自定义函数、Function、Array、RegExp、String、Boolean、Number、Object 4、几乎所有函数都是继承自：Function.prototype（除了Function.prototype） ——&gt;函数.__proto__===Function.prototype ——&gt;Object.__proto__===Function.prototype ——&gt;Function.__proto__===Function.prototype 5、String.prototype.__proto__===Object.prototype Array.prototype.__proto__===Object.prototype Boolean.prototype.__proto__===Object.prototype Number.prototype.__proto__===Object.prototype RegExp.prototype.__proto__===Object.prototype Function.prototype.__proto__===Object.prototype]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象那点事儿-构造函数和原型]]></title>
      <url>%2F2013%2F10%2F02%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[构造函数为什么要有构造函数？ 有一些对象，它们都有共同的特征（属性），就用构造函数来创造这一类型的对象 最直接的好处：一次封装，多次调用，可以省略一些代码，也让代码更加具有可读性 构造函数模式创建对象 ECMAScript中的构造函数可用来创建特定类型的对象如：Array、Date，Object等的原生构造函数，在运行时会自动加入到当前执行环境，当然，也可创建自定义的构造函数，从而实现自定义对象为它添加属性和方法。 12345678910function Xman(name,age)&#123; this.name = name; this.age = age; this.sayHello = function()&#123; console.log("Hello,My name is Xman!"); &#125;;&#125;var man1 = new Xman("金刚狼",30);var man2 = new Xman("万磁王",20); 注意：构造函数应该首字母大写，非构造函数首字母小写 此处的Xman实例，必须使用new操作符，此种方式的操作经历了一下步骤 创建一个新对象 将构造函数的作用域赋给新对象，并将this指向了这个新对象 执行代码，并为这个新对象添加属性和方法 返回执行后的新对象 构造函数与普通函数 其实在javascript中构造函数和普通函数相比，并没有特殊语法。唯一的区别在于调用它们的方式不同，任何普通函数通过new操作符来调用，它就可以被称为构造函数，反之依然。 12345678//构造函数var person = new Xman("金刚狼",19);person.sayHello();//普通函数var person = Xman("金刚狼",19);person.sayHello();//window.sayHello(); 自定义的构造函数虽然实现了隐式创建对象，并且实现了直接将属性、方法赋给this和无return,但是每次创建一次构造函数产生的构造函数方法都会重复创建。当然完全可以把构造函数的方法定义在外面。 123456789function Xman(name,age)&#123; this.name = name; this.age = age; this.sayHello = sayHello;&#125;function sayHello()&#123; console.log("Hello,My name is Xman!");&#125;; 这样做又会出现出现新的问题：具体某个对象调用全局作用域中的函数，会容易造成全局作用域污染，也就不具有封装性了。 构造函数的返回值 构造函数没有返回值，就会利用默认返回值——&gt;Person的实例 12function Person()&#123;&#125;var p1=new Person(); //返回Person的实例--&gt;p1 构造函数有一个返回值（返回值是数字）,还是会利用默认的返回值 1234function Foo()&#123; return 1; //返回Person的实例--&gt;p2&#125;var p2=new Foo(); 构造函数有一个返回值（返回值是对象），新的返回值会覆盖默认的返回值 1234function Cup()&#123; return &#123; name:&quot;张三&quot;&#125;;&#125;var p3=new Cup(); 总结： 1、构造函数没有手动添加返回值，返回构造函数的实例 2、构造函数返回基本数据类型的值，返回的还是构造函数的实例 3、构造函数返回对象类型的值，返回就是那个对象 原型原型对象 以上构造函数遇到的问题可以使用它自身原型来解决共享对象的属性和方法。 123456789101112function Xman()&#123;&#125;;Xman.prototype.name = "金刚狼";Xman.prototype.age = "56";Xman.prototype.sayHello = function()&#123;console.log("Hello,My name is Xman!");&#125;;var person1 = new Xman();person1.sayHello(); //Hello,My name is Xman!var person2 = new Xman();person2.sayHello(); //Hello,My name is Xman! 由此可以看出利用构造函数的原型对象为构造函数的实例添加方法和属性，可以节省内存空间的浪费，因为它的原型对象创建出的属性与方法都被其构造函数的实例所共享。 关于原型的一些结论和推论12345678910111213141516171819202122232425function Student(name,age,number)&#123; this.name=name; this.age=age; this.number=number; this.learnOOP=function()&#123; console.log("学习构造函数、原型、继承"); &#125;;&#125;var s1=new Student("风暴女",33,10);var s2=new Student("瑞文",20,1);var s3=new Student("斯科特",48,3);//对Student实例化3次，就会分配3个不同的learnOOP方法(指向不同的内存空间)，而这3个方法里面的功能都是相同的，这样就//导致了内存的浪费，//如何解决这个问题：使用原型对象//console.log(Student.prototype);Student.prototype.run=function()&#123; console.log("I'm running");&#125;;console.log(s1.run);console.log(s2.run);console.log(s3.run);console.log(s1.run===s2.run);//true 结论1：给构造函数的prototype属性（对象）添加一个方法，这个方法就可以被构造函数的实例所共享 推论：构造函数的prototype属性(对象)上面的属性、方法都可以被构造函数的实例所共享 推论2：Student.prototype.constructor===s1.constructor –&gt;s1查找constructor属性，没有向原型查找 结论2：构造函数的实例有一个proto指向的是构造函数的prototype属性(原型对象) –&gt;s1.proto===Student.prototype 构造函数、原型对象、实例三者之间的关系解释 原型对象是构造函数的prototype属性 构造函数的实例的proto属性指向原型对象 原型对象有一个constructor属性指向构造函数本身 如下图所示 原型对象的属性读取与删除12345678910111213141516function American(name,age,color)&#123; this.name=name; this.age=age; this.color=color;&#125;//设置原型对象的say方法American.prototype.say=function()&#123;&#125;;//删除原型对象中的say方法delete American.prototype.say;//只能删除对象所在的内存中的属性，如果p1对象本身不存在a属性，不会报错//删除了原型对象的constructor属性delete American.prototype.constructor;var jayson = new American();console.log(jayson.constructor);//jayson.__proto__.__proto__中找到--&gt;Object 对象的查找过程 对象的属性查找(获取对象的属性)？ 1、在当前对象(p1)的内存中查找是否定义该属性 2、在当前对象的原型对象中查找是否定义该属性,p1.__proto__(Person.prototype) 3、如果2中没有，就去原型对象的原型对象中去找该属性,p1.__proto__.__proto__...... N、最终找到原型链的顶端（这个对象已经不存在proto属性了）–&gt;Object.prototype–&gt;p1.constructor：是在Peron.prototype对象中找到了该属性]]></content>
    </entry>

    
  
  
</search>
