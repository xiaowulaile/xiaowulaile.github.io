<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuZG&#39;s博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-04T17:09:20.823Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WuZG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Js面向对象那点事儿-继承</title>
    <link href="http://yoursite.com/2013/10/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
    <id>http://yoursite.com/2013/10/05/面向对象之继承那点事儿/</id>
    <published>2013-10-05T13:43:56.000Z</published>
    <updated>2016-11-04T17:09:20.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><blockquote>
<p>  JS继承：将别人的东西拿来自己用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Student.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> s1=<span class="keyword">new</span> Student();</div><div class="line"></div><div class="line">s1.say();</div><div class="line"><span class="comment">//继承关系：s1继承自原型对象——&gt;s1.__proto__===原型对象</span></div><div class="line"></div><div class="line"><span class="comment">//就像a继承自b——&gt;a.__proto__===b</span></div></pre></td></tr></table></figure>
<h2 id="继承的六种方式"><a href="#继承的六种方式" class="headerlink" title="继承的六种方式"></a>继承的六种方式</h2><h3 id="扩展原型继承方式"><a href="#扩展原型继承方式" class="headerlink" title="扩展原型继承方式"></a>扩展原型继承方式</h3><blockquote>
<p>一个构造函数的prototype属性指向默认的原型对象，往默认的原型对象中添加属性、方法就可以为构造函数的实例提供共享的属性和方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">foo1.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"HELLO 1"</span>);&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> kk1 = <span class="keyword">new</span> foo1();</div><div class="line"><span class="built_in">console</span>.log(kk1.getName());</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="替换原型对象继承方式"><a href="#替换原型对象继承方式" class="headerlink" title="替换原型对象继承方式"></a>替换原型对象继承方式</h3><blockquote>
<p>需要往构造函数的原型对象中添加多个属性、方法，如果使用扩展原型对象实现继承，代码冗余（重复）</p>
<p>将构造函数的prototype属性指向一个全新的对象，在这个对象中添加属性、方法(要注意添加constructor属性，指向构造函数本身)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">foo2.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>:foo2,</div><div class="line">    <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">    <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"HELLO 2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> kk2 = <span class="keyword">new</span> foo2();</div><div class="line"><span class="built_in">console</span>.log(kk2.getName());</div></pre></td></tr></table></figure>
<h3 id="混入继承方式"><a href="#混入继承方式" class="headerlink" title="混入继承方式"></a>混入继承方式</h3><blockquote>
<p>已知2个对象（o1,o2），需要将o1的功能拷贝到o2中。</p>
<p>实现方式：for…in遍历o1对象的属性，将其属性值赋值到o2中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//   封装方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">target,source</span>) </span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source)&#123;</div><div class="line">target[key] = source[key];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> target;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">getName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"HELLO 3"</span>)&#125;&#125;;</div><div class="line"><span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o1)&#123;</div><div class="line">    o2[key] = o1[key];</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(o2.getName());</div><div class="line"></div><div class="line"><span class="keyword">var</span> kk3 = mixin(o2,o1);</div><div class="line"><span class="built_in">console</span>.log(kk3.getName());</div></pre></td></tr></table></figure>
<h3 id="原型-混入继承方式"><a href="#原型-混入继承方式" class="headerlink" title="原型+混入继承方式"></a>原型+混入继承方式</h3><blockquote>
<p> 利用混入继承的原理，向原型对象中添加属性、和方法——&gt;mixin(Person.prototype,{a:10,b:function(){})</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//  调用的封装函数同上mixin函数</div><div class="line">var o4 = &#123;getName:function () &#123; console.log(&quot;HELLO 4&quot;)&#125;&#125;;</div><div class="line">var kk4 = mixin(foo1.prototype,o4);</div><div class="line">console.log(kk4.getName());</div></pre></td></tr></table></figure>
<h3 id="经典继承方式"><a href="#经典继承方式" class="headerlink" title="经典继承方式"></a>经典继承方式</h3><blockquote>
<p>已知一个对象o，需要创建一个新的对象(o2)，这个新的对象继承自对象o</p>
<p>由于<strong>proto</strong>不是一个标准属性，不能出现在正式代码中，而且该属性也无法被修改</p>
<p>经典继承的使用场景：要创建一个对象（不需要关心构造函数）新对象需要继承自另一个指定的对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var oo1 = &#123;getName:function () &#123;console.log(&quot;HELLO 5&quot;)&#125;&#125;;</div><div class="line">//必要代码</div><div class="line">function foo5() &#123;&#125;;</div><div class="line">foo5.prototype = oo1;</div><div class="line"></div><div class="line">var kk5 = new foo5();</div><div class="line">console.log(kk5.getName());</div></pre></td></tr></table></figure>
<blockquote>
<p>因为上面的必要代码是一定要有的，所以可以考虑将上面写法进行封装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function create(o)&#123;</div><div class="line">function foo5()&#123;&#125;</div><div class="line">foo5.prototype=o;</div><div class="line"></div><div class="line">return new foo5();//返回的就是foo5的实例</div><div class="line">&#125;</div><div class="line"></div><div class="line">var kk5 = create(o);//kk5.__proto__===o</div></pre></td></tr></table></figure>
<blockquote>
<p>ES5（IE9以下版本不支持）：Object.create()的实现原理就是源自于经典继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//也可这样调用</div><div class="line">var kk5 = Object.create(o);//kk5也是继承自对象o的</div></pre></td></tr></table></figure>
<blockquote>
<p>在旧的浏览器中应用经典继承：</p>
<p>1、首先应该先检测浏览器是否支持Object.create(),所以一般要进行兼容处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if(typeof Object.create !==&quot;function&quot;)&#123;</div><div class="line">    Object.create=function(o)&#123;</div><div class="line">        function F()&#123;&#125;//一个任意的构造函数</div><div class="line">        F.prototype=o;//设置构造函数的原型对象</div><div class="line"></div><div class="line">        return new F();//返回的就是F的实例</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="借用构造函数继承方式"><a href="#借用构造函数继承方式" class="headerlink" title="借用构造函数继承方式"></a>借用构造函数继承方式</h3><blockquote>
<p>利用构造函数继承（结合call/apply）涉及两个构造函数，一个父类构造函数，一个子类构造函数</p>
<p>父类构造函数的所有功能都能被子类构造函数适用</p>
<p>注意：由于要借用父类构造函数，所以父类构造函数的功能要对子类对象通用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo6(getName) &#123;</div><div class="line">    this.getName = getName;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function foo66(getName,ownName) &#123;</div><div class="line">    foo6.call(this,getName);</div><div class="line">    this.ownName = ownName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var kk6 = new  foo66(&quot;HELLO 6&quot;,&quot;tomas&quot;);</div><div class="line">console.log(kk6.getName);  //HELLO 6</div><div class="line">console.log(kk6.ownName);  //tomas</div></pre></td></tr></table></figure>
<blockquote>
<p>由于父构造函数对子构造函数来说，它的属性与方法都是可用的，那么问题出现了：当我自身也拥有和父构造函数一样的属性时，就会出现污染问题，而且这种场景常见，所以借用构造函数实现继承的方式不是首选。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function f1(name,age,gender)&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.age=age;</div><div class="line">    this.gender=&quot;男&quot;;</div><div class="line">&#125;</div><div class="line">function f2(name,age,length)&#123;</div><div class="line">    this.name=name;</div><div class="line">    this.age=age;</div><div class="line">    this.length=length;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function f2(name,age,length)&#123;</div><div class="line">    f1.call(this,name,age);</div><div class="line">    this.length=length;</div><div class="line">&#125;</div><div class="line">var ff2=new f2(&quot;Janda&quot;,16,165);//此处ff2实例拥有name age, gender length这4个属性</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承的概念&quot;&gt;&lt;a href=&quot;#继承的概念&quot; class=&quot;headerlink&quot; title=&quot;继承的概念&quot;&gt;&lt;/a&gt;继承的概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  JS继承：将别人的东西拿来自己用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Student.prototype.say=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Student();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s1.say();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承关系：s1继承自原型对象——&amp;gt;s1.__proto__===原型对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//就像a继承自b——&amp;gt;a.__proto__===b&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;继承的六种方式&quot;&gt;&lt;a href=&quot;#继承的六种方式&quot; class=&quot;headerlink&quot; title=&quot;继承的六种方式&quot;&gt;&lt;/a&gt;继承的六种方式&lt;/h2&gt;&lt;h3 id=&quot;扩展原型继承方式&quot;&gt;&lt;a href=&quot;#扩展原型继承方式&quot; class=&quot;headerlink&quot; title=&quot;扩展原型继承方式&quot;&gt;&lt;/a&gt;扩展原型继承方式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个构造函数的prototype属性指向默认的原型对象，往默认的原型对象中添加属性、方法就可以为构造函数的实例提供共享的属性和方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo1.prototype.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;HELLO 1&quot;&lt;/span&gt;);&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; kk1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; foo1();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(kk1.getName());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Javascript 继承" scheme="http://yoursite.com/tags/Javascript-%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Js面向对象那点事儿-原型链</title>
    <link href="http://yoursite.com/2013/10/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2013/10/04/面向对象那些事儿-原型链/</id>
    <published>2013-10-04T10:34:10.000Z</published>
    <updated>2016-11-04T17:10:01.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型链的概念"><a href="#原型链的概念" class="headerlink" title="原型链的概念"></a>原型链的概念</h2><blockquote>
<p>JS由对象组成，一个对象就有它的原型对象(<strong>proto</strong>)，原型对象也有它的原型对象，一直到原型链的顶端，这样构成了一个具有链条形状的结构，称之为原型链</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//1、对象字面量的原型链</div><div class="line">var o1=&#123; age:10 &#125;;    //new Object()</div><div class="line"></div><div class="line">//2、通过构造函数创建的对象原型链</div><div class="line">function Person(name)&#123;</div><div class="line">    this.name=name;</div><div class="line">&#125;</div><div class="line">var p1=new Person(&quot;威震天&quot;);</div></pre></td></tr></table></figure>
<h2 id="原型链图"><a href="#原型链图" class="headerlink" title="原型链图"></a>原型链图</h2><h3 id="内置对象原型图"><a href="#内置对象原型图" class="headerlink" title="内置对象原型图"></a>内置对象原型图</h3><blockquote>
<p>结合构造函数、原型对象、实例三者之间的关系</p>
<ul>
<li>原型对象是构造函数的prototype属性</li>
<li>构造函数的实例的<strong>proto</strong>属性指向原型对象</li>
<li>原型对象有一个constructor属性指向构造函数本身</li>
</ul>
<p>内置对象以数组为例，已知数组arr = [1,3,5];,则可以得出<code>arr.__proto__===Array.prototype</code><br>,<code>arr.__proto__.__proto__===Object.prototype</code></p>
</blockquote>
<a id="more"></a>
<p><img src="/images/1.jpg" alt="内置对象原型图"></p>
<h3 id="内置对象与对象原型图"><a href="#内置对象与对象原型图" class="headerlink" title="内置对象与对象原型图"></a>内置对象与对象原型图</h3><p><img src="/images/2.jpg" alt="内置对象与对象原型图"></p>
<h3 id="函数原型图"><a href="#函数原型图" class="headerlink" title="函数原型图"></a>函数原型图</h3><h4 id="函数的创建"><a href="#函数的创建" class="headerlink" title="函数的创建"></a>函数的创建</h4><blockquote>
<p>任何函数都是通过Function创建出来的（任何函数都是Function的实例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function f()&#123;&#125;//new Function()</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><p>创建一个无参无返回值的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var f1=new Function(&quot;var a=1;var b=2;console.log(a+b);&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>创建一个有一个参数，无返回值的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var f2=new Function(&quot;num&quot;,&quot;console.log(num);&quot;);</div><div class="line">f2(10);</div></pre></td></tr></table></figure>
</li>
<li><p>创建一个具有3个参数，有返回值的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var f3=new Function(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;return a+b+c; &quot;);</div><div class="line">console.log(f3(1,3,5));</div></pre></td></tr></table></figure>
</li>
<li><p>创建一个经典继承的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var f5=new Function(&quot;o&quot;,&quot;function F()&#123;&#125; &quot; +</div><div class="line">&quot;F.prototype=o;&quot; +</div><div class="line">&quot;return new F();&quot;);</div><div class="line">console.log(f5(&#123;age:10&#125;));</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="一些总结："><a href="#一些总结：" class="headerlink" title="一些总结："></a>一些总结：</h4><blockquote>
<ul>
<li><p>1、几乎所有函数都有prototype属性（Function.prototype这个函数上没有）</p>
</li>
<li><p>2、所有对象中都有__proto__属性（Object.prototype该属性的值null）</p>
<p>   ——&gt;几乎所有函数都有prototype__proto__属性</p>
</li>
<li><p>3、函数都是Function的实例（函数是通过Function创建出来的对象）</p>
<p>   ——&gt;自定义函数、Function、Array、RegExp、String、Boolean、Number、Object</p>
</li>
<li><p>4、几乎所有函数都是继承自：Function.prototype（除了Function.prototype）</p>
<p>   ——&gt;函数.__proto__===Function.prototype</p>
<p>   ——&gt;Object.__proto__===Function.prototype</p>
<p>   ——&gt;Function.__proto__===Function.prototype</p>
</li>
<li><p>5、String.prototype.__proto__===Object.prototype</p>
<p>   Array.prototype.__proto__===Object.prototype</p>
<p>   Boolean.prototype.__proto__===Object.prototype</p>
<p>   Number.prototype.__proto__===Object.prototype</p>
<p>   RegExp.prototype.__proto__===Object.prototype</p>
<p>   Function.prototype.__proto__===Object.prototype</p>
</li>
</ul>
</blockquote>
<p><img src="/images/3.jpg" alt="函数原型图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型链的概念&quot;&gt;&lt;a href=&quot;#原型链的概念&quot; class=&quot;headerlink&quot; title=&quot;原型链的概念&quot;&gt;&lt;/a&gt;原型链的概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JS由对象组成，一个对象就有它的原型对象(&lt;strong&gt;proto&lt;/strong&gt;)，原型对象也有它的原型对象，一直到原型链的顶端，这样构成了一个具有链条形状的结构，称之为原型链&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//1、对象字面量的原型链&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var o1=&amp;#123; age:10 &amp;#125;;    //new Object()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//2、通过构造函数创建的对象原型链&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;function Person(name)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    this.name=name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var p1=new Person(&amp;quot;威震天&amp;quot;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;原型链图&quot;&gt;&lt;a href=&quot;#原型链图&quot; class=&quot;headerlink&quot; title=&quot;原型链图&quot;&gt;&lt;/a&gt;原型链图&lt;/h2&gt;&lt;h3 id=&quot;内置对象原型图&quot;&gt;&lt;a href=&quot;#内置对象原型图&quot; class=&quot;headerlink&quot; title=&quot;内置对象原型图&quot;&gt;&lt;/a&gt;内置对象原型图&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;结合构造函数、原型对象、实例三者之间的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型对象是构造函数的prototype属性&lt;/li&gt;
&lt;li&gt;构造函数的实例的&lt;strong&gt;proto&lt;/strong&gt;属性指向原型对象&lt;/li&gt;
&lt;li&gt;原型对象有一个constructor属性指向构造函数本身&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内置对象以数组为例，已知数组arr = [1,3,5];,则可以得出&lt;code&gt;arr.__proto__===Array.prototype&lt;/code&gt;&lt;br&gt;,&lt;code&gt;arr.__proto__.__proto__===Object.prototype&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Js面向对象那点事儿-构造函数与原型</title>
    <link href="http://yoursite.com/2013/10/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
    <id>http://yoursite.com/2013/10/02/面向对象之构造函数和原型那点事儿/</id>
    <published>2013-10-02T15:19:49.000Z</published>
    <updated>2016-11-04T17:07:56.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="为什么要有构造函数？"><a href="#为什么要有构造函数？" class="headerlink" title="为什么要有构造函数？"></a>为什么要有构造函数？</h3><ul>
<li>有一些对象，它们都有共同的特征（属性），就用构造函数来创造这一类型的对象</li>
<li>最直接的好处：一次封装，多次调用，可以省略一些代码，也让代码更加具有可读性</li>
</ul>
<h3 id="构造函数模式创建对象"><a href="#构造函数模式创建对象" class="headerlink" title="构造函数模式创建对象"></a>构造函数模式创建对象</h3><blockquote>
<p>ECMAScript中的构造函数可用来创建特定类型的对象如：Array、Date，Object等的原生构造函数，在运行时会自动加入到当前执行环境，当然，也可创建自定义的构造函数，从而实现自定义对象为它添加属性和方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Xman</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello,My name is Xman!"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> man1 = <span class="keyword">new</span> Xman(<span class="string">"金刚狼"</span>,<span class="number">30</span>);</div><div class="line"><span class="keyword">var</span> man2 = <span class="keyword">new</span> Xman(<span class="string">"万磁王"</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure>
<p><code>注意：构造函数应该首字母大写，非构造函数首字母小写</code></p>
<p>此处的Xman实例，必须使用new操作符，此种方式的操作经历了一下步骤</p>
<ul>
<li><p>创建一个新对象</p>
</li>
<li><p>将构造函数的作用域赋给新对象，并将this指向了这个新对象</p>
</li>
<li><p>执行代码，并为这个新对象添加属性和方法</p>
</li>
<li><p>返回执行后的新对象</p>
<a id="more"></a>
<h3 id="构造函数与普通函数"><a href="#构造函数与普通函数" class="headerlink" title="构造函数与普通函数"></a>构造函数与普通函数</h3><blockquote>
<p>其实在javascript中构造函数和普通函数相比，并没有特殊语法。唯一的区别在于调用它们的方式不同，任何普通函数通过new操作符来调用，它就可以被称为构造函数，反之依然。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Xman(<span class="string">"金刚狼"</span>,<span class="number">19</span>);</div><div class="line">person.sayHello();</div><div class="line"></div><div class="line"><span class="comment">//普通函数</span></div><div class="line"><span class="keyword">var</span> person = Xman(<span class="string">"金刚狼"</span>,<span class="number">19</span>);</div><div class="line">person.sayHello();</div><div class="line"><span class="comment">//window.sayHello();</span></div></pre></td></tr></table></figure>
<blockquote>
<p>自定义的构造函数虽然实现了隐式创建对象，并且实现了直接将属性、方法赋给this和无return,但是每次创建一次构造函数产生的构造函数方法都会重复创建。当然完全可以把构造函数的方法定义在外面。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Xman</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayHello = sayHello;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello,My name is Xman!"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>这样做又会出现出现新的问题：具体某个对象调用全局作用域中的函数，会容易造成全局作用域污染，也就不具有封装性了。</p>
</blockquote>
<h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><ul>
<li><p>构造函数没有返回值，就会利用默认返回值——&gt;Person的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">var p1=new Person();    //返回Person的实例--&gt;p1</div></pre></td></tr></table></figure>
</li>
<li><p>构造函数有一个返回值（返回值是数字）,还是会利用默认的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;</div><div class="line">    return 1;       //返回Person的实例--&gt;p2</div><div class="line">&#125;</div><div class="line">var p2=new Foo();</div></pre></td></tr></table></figure>
</li>
<li><p>构造函数有一个返回值（返回值是对象），新的返回值会覆盖默认的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cup()&#123;</div><div class="line">    return &#123; name:&quot;张三&quot;&#125;;</div><div class="line">&#125;</div><div class="line">var p3=new Cup();</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>总结：</strong></p>
<p><strong>1、构造函数没有手动添加返回值，返回构造函数的实例</strong></p>
<p><strong>2、构造函数返回基本数据类型的值，返回的还是构造函数的实例</strong></p>
<p><strong>3、构造函数返回对象类型的值，返回就是那个对象</strong></p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><blockquote>
<p>以上构造函数遇到的问题可以使用它自身原型来解决共享对象的属性和方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Xman</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Xman.prototype.name = <span class="string">"金刚狼"</span>;</div><div class="line">Xman.prototype.age = <span class="string">"56"</span>;</div><div class="line">Xman.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hello,My name is Xman!"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Xman();</div><div class="line">person1.sayHello();   <span class="comment">//Hello,My name is Xman!</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Xman();</div><div class="line">person2.sayHello();   <span class="comment">//Hello,My name is Xman!</span></div></pre></td></tr></table></figure>
<blockquote>
<p>由此可以看出利用构造函数的原型对象为构造函数的实例添加方法和属性，可以节省内存空间的浪费，因为它的原型对象创建出的属性与方法都被其构造函数的实例所共享。</p>
</blockquote>
<h3 id="关于原型的一些结论和推论"><a href="#关于原型的一些结论和推论" class="headerlink" title="关于原型的一些结论和推论"></a>关于原型的一些结论和推论</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,number</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.number=number;</div><div class="line">    <span class="keyword">this</span>.learnOOP=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"学习构造函数、原型、继承"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> s1=<span class="keyword">new</span> Student(<span class="string">"风暴女"</span>,<span class="number">33</span>,<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> s2=<span class="keyword">new</span> Student(<span class="string">"瑞文"</span>,<span class="number">20</span>,<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> s3=<span class="keyword">new</span> Student(<span class="string">"斯科特"</span>,<span class="number">48</span>,<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">//对Student实例化3次，就会分配3个不同的learnOOP方法(指向不同的内存空间)，而这3个方法里面的功能都是相同的，这样就</span></div><div class="line"><span class="comment">//导致了内存的浪费，</span></div><div class="line"><span class="comment">//如何解决这个问题：使用原型对象</span></div><div class="line"><span class="comment">//console.log(Student.prototype);</span></div><div class="line"></div><div class="line">Student.prototype.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"I'm running"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(s1.run);</div><div class="line"><span class="built_in">console</span>.log(s2.run);</div><div class="line"><span class="built_in">console</span>.log(s3.run);</div><div class="line"><span class="built_in">console</span>.log(s1.run===s2.run);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>结论1：给构造函数的prototype属性（对象）添加一个方法，这个方法就可以被构造函数的实例所共享</p>
<p>推论：构造函数的prototype属性(对象)上面的属性、方法都可以被构造函数的实例所共享</p>
<p>推论2：Student.prototype.constructor===s1.constructor   –&gt;s1查找constructor属性，没有向原型查找</p>
<p>结论2：构造函数的实例有一个<strong>proto</strong>指向的是构造函数的prototype属性(原型对象)<br>  –&gt;s1.<strong>proto</strong>===Student.prototype</p>
</blockquote>
<h3 id="构造函数、原型对象、实例三者之间的关系解释"><a href="#构造函数、原型对象、实例三者之间的关系解释" class="headerlink" title="构造函数、原型对象、实例三者之间的关系解释"></a>构造函数、原型对象、实例三者之间的关系解释</h3><ul>
<li>原型对象是构造函数的prototype属性</li>
<li>构造函数的实例的<strong>proto</strong>属性指向原型对象</li>
<li>原型对象有一个constructor属性指向构造函数本身</li>
</ul>
<blockquote>
<p>如下图所示</p>
</blockquote>
<p><img src="/images/img.jpg" alt="原型图"></p>
<h3 id="原型对象的属性读取与删除"><a href="#原型对象的属性读取与删除" class="headerlink" title="原型对象的属性读取与删除"></a>原型对象的属性读取与删除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">American</span>(<span class="params">name,age,color</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.color=color;</div><div class="line">&#125;</div><div class="line"><span class="comment">//设置原型对象的say方法</span></div><div class="line">American.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//删除原型对象中的say方法</span></div><div class="line"><span class="keyword">delete</span> American.prototype.say;<span class="comment">//只能删除对象所在的内存中的属性，如果p1对象本身不存在a属性，不会报错</span></div><div class="line"></div><div class="line"><span class="comment">//删除了原型对象的constructor属性</span></div><div class="line"><span class="keyword">delete</span> American.prototype.constructor;</div><div class="line"></div><div class="line"><span class="keyword">var</span> jayson = <span class="keyword">new</span> American();</div><div class="line"><span class="built_in">console</span>.log(jayson.constructor);<span class="comment">//jayson.__proto__.__proto__中找到--&gt;Object</span></div></pre></td></tr></table></figure>
<h3 id="对象的查找过程"><a href="#对象的查找过程" class="headerlink" title="对象的查找过程"></a>对象的查找过程</h3><blockquote>
<p>对象的属性查找(获取对象的属性)？</p>
<p>1、在当前对象(p1)的内存中查找是否定义该属性</p>
<p>2、在当前对象的原型对象中查找是否定义该属性,<code>p1.__proto__(Person.prototype)</code></p>
<p>3、如果2中没有，就去原型对象的原型对象中去找该属性,<code>p1.__proto__.__proto__......</code></p>
<p>N、最终找到原型链的顶端（这个对象已经不存在<strong>proto</strong>属性了）–&gt;Object.prototype<br>–&gt;p1.constructor：是在Peron.prototype对象中找到了该属性</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;h3 id=&quot;为什么要有构造函数？&quot;&gt;&lt;a href=&quot;#为什么要有构造函数？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有构造函数？&quot;&gt;&lt;/a&gt;为什么要有构造函数？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有一些对象，它们都有共同的特征（属性），就用构造函数来创造这一类型的对象&lt;/li&gt;
&lt;li&gt;最直接的好处：一次封装，多次调用，可以省略一些代码，也让代码更加具有可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;构造函数模式创建对象&quot;&gt;&lt;a href=&quot;#构造函数模式创建对象&quot; class=&quot;headerlink&quot; title=&quot;构造函数模式创建对象&quot;&gt;&lt;/a&gt;构造函数模式创建对象&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ECMAScript中的构造函数可用来创建特定类型的对象如：Array、Date，Object等的原生构造函数，在运行时会自动加入到当前执行环境，当然，也可创建自定义的构造函数，从而实现自定义对象为它添加属性和方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Xman&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name,age&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sayHello = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;Hello,My name is Xman!&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; man1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Xman(&lt;span class=&quot;string&quot;&gt;&quot;金刚狼&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; man2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Xman(&lt;span class=&quot;string&quot;&gt;&quot;万磁王&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;注意：构造函数应该首字母大写，非构造函数首字母小写&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此处的Xman实例，必须使用new操作符，此种方式的操作经历了一下步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建一个新对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将构造函数的作用域赋给新对象，并将this指向了这个新对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行代码，并为这个新对象添加属性和方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回执行后的新对象&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
